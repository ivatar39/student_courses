Язык Go известен как язык для разработки асихнхронного кода, потому что на нем очень легко писать его. Go используют горутины - это легковесные потоки управленмые рантаймом языка.

Чтобы вызвать горутину достаточно перед функцией написать ключевое слово `go`.

```go
func say(s string) {
	for i := 0; i < 5; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Println(s)
	}
}

func main() {
	go say("world")
	say("hello")
}
```

Каналы — это типизированный канал, через который вы можете отправлять и получать значения с помощью оператора канала `<-`. Они создаются через функцию `make` и могут быть как буферезиованные так и не буферезированные. И часто используются для передачи данных между горутинами и их синхронизации.
```go
c := make(chan int)
c <- 1 // Кладем в канал значение 1.
v := <-c // Читаем из канала последнее положенное в него значение.
```
Чтобы создать буфферезированный канал, вторым аргументом в фунцкию `make` нужно передать значение, которое задаст его размер.

```go 
c := make(chan int, 100)
```

Можно создать канал который будет только передавать или только принимать данные:

```go
w := make(<-chan int) // для чтения
r := make(chan<- int) // для записи
```

Он будет принимать значение, пока полностью не забьётся, чтобы освободить его, их просто нужно будет прочитать через оператор `<-`.

Отправитель может закрыть канал, чтобы указать, что значения больше не будут отправляться. Получатели могут проверить, был ли закрыт канал, назначив второй параметр выражению приема:

```go
v, ok := <-c
```

Если `ok` равен `false,` то канал закрыт. Еще можно использовать цикл `for i := range c` пока канал не будет закрыт.

Чтение или запись данных в канал блокирует горутину и контроль передается свободной горутине. Если такие горутины отсутствуют либо они все “спят” в этот момент может возникнут deadlock который приведет к завершению программы.

Если вы попытаетесь считать данные из канала, но в канале будут отсутствовать данные, планировщик заблокирует текущую горутину и разблокирует другую в надежде, что какая-либо горутина передаст данные в канал. То же самое произойдет в случае отправки данных: планировщик заблокирует передающую горутину, пока другая не считает данные из канала.

```go
// Проверка закрыт ли канал
val, ok := <- channel
if ok == false {
    fmt.Print("Канал закрыт")
} else {
    fmt.Print("Канал открыт")
}

// Если использовать range то автоматически завершится цикл когда канал будет закрыт
for val := range channel {
    fmt.Print(val)
}

runtime.NumGoroutine() // можно вывести номер goroutine обычно 1 это main
```

Горутина не блокируется до тех пор пока буфер не будет заполнен, но при чтении из канала операция не будет завершена пока не опустошит весь буфер!

Оператор `select` позволяет горутине ожидать нескольких коммуникационных операций. `select` блокируется до тех пор, пока не сможет запуститься один из его кейсов, затем он выполняет этот кейс. Он выбирает один случайным образом, если готовы несколько. Кейс `default` в выборе запускается, если нет другого кейса.

```go
func main() {
	tick := time.Tick(100 * time.Millisecond)
	boom := time.After(500 * time.Millisecond)
	for {
		select {
		case <-tick:
			fmt.Println("tick.")
		case <-boom:
			fmt.Println("BOOM!")
			return
		default:
			fmt.Println("    .")
			time.Sleep(50 * time.Millisecond)
		}
	}
}
```

Одним из методов синхронизации горутин в Go используются мьютексы, которые находятся в пакете `sync`, они позволяют только одной горутине иметь доступ к данным, пока другие остаются в ожидание. Это позволяет сделать `sync.Mytex`, который обладает двумя методами `Lock` и `Unlock`. Когда горутина получается доступ к данным, мы используем `Lock` при этом отправляя другие горутины в ожидание, пока нынещняя не закончит свою работу, после это мы уже используем `Unlock`, освобождания структуру данных для других горутин. Это полезно использовать при работе с файлами или такими струтурами данных как `map`.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

type SafeCounter struct {
	mu sync.Mutex
	v  map[string]int
}

// Inc инкремент нашей структуры, который принимает ключ.
func (c *SafeCounter) Inc(key string) {
	c.mu.Lock()
	// Блокировка, чтобы только одна горутина могла получить доступ к карте c.v.
	c.v[key]++
	c.mu.Unlock()
}

// Value возвращает текущее значение по ключу.
func (c *SafeCounter) Value(key string) int {
	c.mu.Lock()
	// Блокировка, чтобы только одна горутина могла получить доступ к карте c.v. 
	defer c.mu.Unlock()
	return c.v[key]
}

func main() {
	c := SafeCounter{v: make(map[string]int)}
	for i := 0; i < 1000; i++ {
		go c.Inc("somekey")
	}

	time.Sleep(time.Second)
	fmt.Println(c.Value("somekey"))
}
```

Также можно использовать `RWMutex`, вместо обычного, он позволяет читать сразу нескольким горутинам, а записывать только одной, это полезно, если структура данных безопасна для асинхронного чтения, например такая как `map`. Переписанных код сверху на RWMutex.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

type SafeCounter struct {
	mu sync.RWMutex
	v  map[string]int
}

// Inc инкремент нашей структуры, который принимает ключ.
func (c *SafeCounter) Inc(key string) {
	c.mu.Lock()
	// Блокировка, чтобы только одна горутина могла получить доступ к карте c.v.
	c.v[key]++
	c.mu.Unlock()
}

// Value возвращает текущее значение по ключу.
func (c *SafeCounter) Value(key string) int {
	c.mu.RLock()
	// Блокировка, чтобы только горутины для чтения могли получить доступ к карте c.v. 
	defer c.mu.RUnlock()
	return c.v[key]
}

func main() {
	c := SafeCounter{v: make(map[string]int)}
	for i := 0; i < 1000; i++ {
		go c.Inc("somekey")
	}

	time.Sleep(time.Second)
	fmt.Println(c.Value("somekey"))
}
```