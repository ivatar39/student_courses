<h2>Packages</h2>

Все программы в Go используют пакеты.

Пример программы, которая использует пакеты `fmt` и `math/rand`:

```go
package main

import (
	"fmt"
	"math/rand"
)

func main() {
	fmt.Println("My favorite number is", rand.Intn(10))
}
```

Имя пакета совпадает с последним элементом пути импорта.Также импорты можно группировать как указано в примере выше, вместо того, чтобы писать импорт каждого пакета:

```go
import "fmt"
import "math/rand"
```

В Go можно импортировать функции, переменные, структуры только если они начинаются с заглавной буквы.

Функции могут принимать 0 или безграничное количество аргументов и когда аргументы имееют один тип, их можно записать так:

```go
func add(x, y int) int {
	return x + y
}
```

Вместо:

```go
func add(x int, y int) int {
	return x + y
}
```

Также функция может возращать неограниченное количество результатов, например:

```go
func swap(x, y string) (string, string) {
	return y, x
}
```

Также возвращаемые переменные можно сразу инициализировать указав их в возрате функции и тогда `return` можно указывать пустым, например:

```go
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
```

Перенные объявляются словом `var` после которого следует имя переменной и её тип, но также можно их указывать и списком, если все имеют один тип:

```go
var a, b, c int8
var i int
```

Также их можно сгрупировать:

```go
var (
	a, b, c int8
	i int
)
```

Пеменным можно задать значение различными спопсобами, явно указать тип, или `Go` сам определит его:

```go
var i, j int = 1, 2
var c, python, java = true, false, "no!"
```

Также есть более короткий способ `:=`, который обычно всегда и используют, он также сам определяет тип переменной, но не нужно использовать его на уже объявленной ранее переменной:

```go
a := 10
```

Основные типы Go:
```go
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // или uint8

rune // или int32
     // используется в Unicode

float32 float64

complex64 complex128
```

Нулевые значения для типов:
```go
0 для чисел,
false для булевых,
"" (пустая строка) для строк.
```

Конвертация чисел:
```Go
i := 42
f := float64(i)
u := uint(f)
```

Константы объявляются также как и переменные, только с ключевым словом `const` и не могу объявляться через `:=`. Константа использует такие типы как строка, символ, булевый и числовой.

```
const Pi = 3.14
```

Также константа принимает тип данных от контекста.

Строки в Go являются неизменяемой последовательностью байтов, из чего следует несколько выводов:

* На строке работают операции массивов и срезов.
* Чтобы изменить строку, нужно создать новую.
* Итерируюсь по строке, мы будем итерироваться по байтам.
* Мы можем определить в строке под строку.

Также строку можно создать не только с `""`, а также и с `` обратным апострофом. Разница в том, что двойные ковычки позволяют использовать управляющие символы.

Для работы со строками выделена целая библиотека `strings`, и вот несколько примеров:

```go
// Содержится ли подстрока в строке    
strings.Contains("test", "es"), 
// результат: true

// Кол-во подстрок в строке
strings.Count("test", "t"),
// результат: 2

// Начинается ли строка с префикса       
strings.HasPrefix("test", "te"), 
// результат: true

// Заканчивается ли строка суффиксом
strings.HasSuffix("test", "st"), 
// результат: true

// Возвращает начальный индекс подстроки в строке, а при отсутствии вхождения возвращает -1
strings.Index("test", "e"), 
// результат: 1

// объединяет массив строк через символ
strings.Join([]string{"hello","world"}, "-"),
// результат: "hello-world"

// Повторяет строку n раз подряд
strings.Repeat("a", 5), 
// результат: "aaaaa"

// Функция Replace заменяет любое вхождение old в вашей строке на new
// Если значение n равно -1, то будут заменены все вхождения.
// Общий вид: func Replace(s, old, new string, n int) string
// Пример:
strings.Replace("blanotblanot", "not", "***", 	-1),
// результат: "bla***bla***"
 
// Разбивает строку согласно разделителю
strings.Split("a-b-c-d-e", "-"), 
// результат: []string{"a","b","c","d","e"}

// Возвращает строку c нижним регистром
strings.ToLower("TEST"), 
// результат: "test"

// Возвращает строку c верхним регистром
strings.ToUpper("test"), 
// результат: "TEST"

// Возвращает строку с вырезанным набором
strings.Trim("tetstet", "te"),
// результат: s
```

Также помимо пакета `strings`, есть пакет `unicode`. Некоторые примеры из него:
```go
// функции ниже принимают на вход тип rune

// проверка символа на цифру
unicode.IsDigit('1') // true
// проверка символа на букву
unicode.IsLetter('a') // true 
// проверка символа на нижний регистр
unicode.IsLower('A') // false
// проверка символа на верхний регистр
unicode.IsUpper('A') // true
// проверка символа на пробел 
// пробел это не только ' ', но и:
//  '\t', '\n', '\v', '\f', '\r' - подробнее читайте в документации
unicode.IsSpace('\t') // true 

// С помощью функции Is можно проверять на кастомный RangeTable:
// например, проверка на латиницу:
unicode.Is(unicode.Latin, 'ы') // false


// функции преобразований
string(unicode.ToLower('F')) // f
string(unicode.ToUpper('f')) // F
```

<h3>Состояние контроля</h3>

В Go есть одна функия цикла и называетя она `for`, и по конструкции похожа на for из языка C.

```Go
func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}

```

Она также заменяет функцию `while`:

```Go
for sum < 1000 {
	sum += sum
}
```

А чтобы сделать бесконечный цикл достаточно ничего не указывать:

```go
for {
}
```

Конструкция `if` выглядит следующим образом:

```go
if x < 0 {
	return false
}
```

В `if` можно объявлять переменные и передавать им значения, но жить они будут только внутри конструкции и за её пределы не выйдут:

```go
if v := math.Pow(x, n); v < l {
	return v
}
```

C `else` это будет выглядеть так:

```go
if v < 0 {
	return v
} else {
	return v * v
}
```

Также есть конструкция с `else if`:

```go
if v < 0 {
	return v
} else if v * v > 10 {
	return v
} else {
	return v * v
}
```

Конструкцию `if` можно заменить конструкцией `switch case`:

```go
func main() {
	fmt.Println("When's Saturday?")
	today := time.Now().Weekday()
	switch time.Saturday {
	case today + 0:
		fmt.Println("Today.")
	case today + 1:
		fmt.Println("Tomorrow.")
	case today + 2:
		fmt.Println("In two days.")
	default:
		fmt.Println("Too far away.")
	}
}
```

`Switch` можно использовать без условия:

```go
func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
}
```

В `Go` есть функция отложенного вызова `defer`, она вызывается в конце выполнения функции:

```go
func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}
```

В языке также имеются указатели на адрес в памяти, в котором хранится значение переменной:

```go
func main() {
	i, j := 42, 2701

	p := &i         // указатель на i
	fmt.Println(*p) // чтение значения i
	*p = 21         // присвоить i значение 21 через указатель
	fmt.Println(i)  // вывести новое значение i

	p = &j         // указатель на j
	*p = *p / 37   // поделить j через указатель
	fmt.Println(j) // вывести новое значение j
}
```

Массивы имеют следующую структуру `[n]T` где n количество элементов, а T их тип.

Пример по созданию массива из 10 чисел:
```go
var a [10]int
```

Все 10 чисел являются 0.

В языке также есть слайсы, они имеют такую же структуру, как и массив, но по сравнению с массивом они имеют динамическую длину.

Пример по созданию слайса с неограниченной длиной:

```go
var b []int
```

Будет создан пустой слайс.

Литералы слайсы и массива:

```GO
arrayL := [3]bool{true, true, false} // массив

sliceL := []bool{true, true, false} // слайс
```

Слайс имеет как длину, так и емкость.

Длина слайса — это количество элементов, которые он содержит.

Емкость слайса — это количество элементов в базовом массиве, считая от первого элемента в срезе.

Длину и емкость слайса s можно получить, используя выражения len(s) и cap(s).

Нулевое значение слайса равно nil.

Нулевой срез имеет длину и емкость 0 и не имеет базового массива.

Слайс также можно создать через встроенную функцию `make()`.

```go
a := make([]int, 5)  // len(a)=5

b := make([]int, 0, 5) // len(b)=0, cap(b)=5
```

Добавление элементов происходит через функцию `append()`, которая имеет такую структуру:
```go
func append(s []T, vs ...T) []T
```
Пример использования:
```go
a = append(a, 34)
```

Пройти по массиву или слайсу можно с помощью функции `range`:
```go
for i, v := range a {
	fmt.Println(i, v) // где i - это индекс элемента, а v его значение
}
```

Если нужно использовать только значение, то используется такая конструкция:
```go
for _, v := range a 
```
Если только индекс:
```go
for i := range a 
```

В go есть структура данных как `map`, которая сопоставляет ключи со значениями.

Нулевое значение карты равно `nil`. Карта `nil` не имеет ключей и не может быть добавлена.

Функция `make` возвращает `map` заданного типа, инициализированную и готовую к использованию.

Вставка или обновление элементов `map`:
```
m[key] = elem
```
Перезапись елемента:
```
elem = m[key]
```

Удаление элемента:

```
delete(m, key)
```

Проверка существует ли ключ:
```
elem, ok := m[key]
```

Если ключ существует, то в переменной `ok` будет значение `true`, иначе `false`.

Функции тоже являются значениями. Их можно передавать так же, как и другие значения.

Значения функции могут использоваться в качестве аргументов функции и возвращаемых значений.

Функции Go могут быть замыканиями. Замыкание — это значение функции, которое ссылается на переменные вне своего тела. Функция может обращаться к указанным переменным и присваивать им значения; в этом смысле функция «привязана» к переменным.

Например, функция сумматора возвращает замыкание. Каждое замыкание связано со своей собственной переменной суммы.

