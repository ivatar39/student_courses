Самые распространненные задачи на собеседованиях по Go связаны с асинхронным программированием, мы расмотрим некоторые из самых популярных.

**Написать генерератор случайных чисел.**

Для решения задачи будем использовать небуферезированный канал и асинхронно записывать туда случайные числа. После закроем канал, как закончим запись.

```go
package main

import (
	"fmt"
	"math/rand" // Импортируем библиотеку для случайных чисел
	"time"
)

func randNumsGenerator(n int) <-chan int { // Возвращение значения из читаемого канала
	r := rand.New(rand.NewSource(time.Now().UnixNano())) // Создаем и запускаем генератор
    // При использование не фикс. начального значения такой как time.Now().UnixNano(), каждый раз при запуске генератор будет давать случайные числа

	out := make(chan int) // Создаем не буфф канал для записи рандомных чисел
	go func() { // горутина для записи
		for i := 0; i < n; i++ {
			out <- r.Intn(n) // генерация числа с 0 до n и запись его в канал
		}
		close(out) // закрытие канала
	}()
	return out
}

func main() {
	for num := range randNumsGenerator(10) {
		fmt.Println(num)
	}
}
```

**Слить n каналов в один**

Даны `n` каналов типа `chan int`. Надо написать функцию, которая сольет все данные из этих каналов в один и вернет его. Напишем функцию, которая будет асинхронноь читать из исходных каналов, которые ей будут переданы и записывать все в результирующий канал. Результирующий канал будет не буфферезированный, потому что нам не известно сколько придёт данных из других каналов. Далее просто асинхронно прочитаем из исходных канало и закроем результирующий, когда закончится чтение.

```go
package main

import (
	"fmt"
	"sync"
)

func joinChannels(chs ...<-chan int) <-chan int { // принимаем на вход любое кол-во каналов, которые будут лежать в массиве и будем возвращать значения
	mergedCh := make(chan int) // результирующий канал

	go func() { // управляющая горутина
		wg := &sync.WaitGroup{} // создаем переменную, которая будет отвечать за ожидания горутин 

		wg.Add(len(chs)) // добавляем в колекцию кол-во горутин, которые мы будем ожидать

		for _, ch := range chs { // проход по массиву с каналами
			go func(ch <-chan int, wg *sync.WaitGroup) { // горутина для асинхронного чтения
				defer wg.Done() // в конце говорим, что горутина закончила свою работу
				for id := range ch {
					mergedCh <- id // запись в результирующий канал
				}
			}(ch, wg)
		}

		wg.Wait() // ожидания окончания работы всех горутин работы 
		close(mergedCh) // закрытие результирующего канала
	}()

	return mergedCh
}

func main() {

	a := make(chan int)
	b := make(chan int)
	c := make(chan int)

	go func() {
		for _, num := range []int{1, 2, 3} {
			a <- num
		}
		close(a)
	}()

	go func() {
		for _, num := range []int{20, 10, 30} {
			b <- num
		}
		close(b)
	}()

	go func() {
		for _, num := range []int{300, 200, 100} {
			c <- num
		}
		close(c)
	}()

	for num := range joinChannels(a, b, c) {
		fmt.Println(num)
	}

}
```

**Написать WorkerPool с заданной функцией** 

Нам нужно разбить процессы на несколько горутин — при этом не создавать новую горутину каждый раз, а просто переиспользовать уже имеющиеся. Для этого создадим канал с джобами и результирующий канал. Для каждого воркера создадим горутину, который будет ждать новую джобу, применять к ней заданную функцию и пулять ответ в результирующий канал.

```go
package main

import (
	"fmt"
)

func worker(f func(int) int, jobs <-chan int, results chan<- int) {
    for j := range jobs { // Чтени из канала в ожидании работы
        results <- f(j) // Выполняется когда приходит работа
    }
}

func main() {

    const numJobs = 5
    jobs := make(chan int, numJobs) // Создание канала с буфером 5
    results := make(chan int, numJobs) // Создание канала с буфером 5

    multiplier := func(x int) int { // функция для канала
	    return x * 10
    }

    go worker(multiplier, jobs, results) // запускаем работу
    

    for j := 1; j <= numJobs; j++ {
        jobs <- j // отправляем джобу для воркера
    }
    close(jobs) // закрываем канал для записи

    for i := 1; i <= numJobs; i++ {
        fmt.Println(<-results) // вывод резульата
    }
}
```