Важность автоматизации

На заре разработки ПО, все тестирование происходило мануально. Перед каждым выпуском софта программисты и тестировщики руками проверяли корректность работы приложения. Как вы понимаете, такой подход крайне непрактичен и отнимает уйму времени.

На сегодняшний день, любая команда разработки ПО стремится как можно быстрее добавлять новые фичи, или улучшать старые, при этом оперативно и безболезненно доставлять их в продакшн. Это стремление породило практику непрерывной доставки и развертывания, которая позволяет выпускать новые версии продуктов гарантированно и автоматически, хоть по несколько раз на день.

Достигается это за счет автоматизации большинства процессов, от сборки и тестирования до развертывания приложений на инфраструктуре.

Поэтому очень важно покрывать приложение тестами и автоматизировать их. Это позволяет сразу отлавливать ошибки при разработке или развертывании. Такой подход оперативен и экономит много времени и ресурсов.

Для тестирования своих программ в golang есть специальный пакет `testing`. Также нужно придерживаться некоторых правил при написание тестов:

1. Файл должен заканчиваться на `_test.go`.
2. Функция должна иметь сигнатуру `func(*testing.T)`.
3. Имя функции должно начинаться с `Test`.

Хорошая структура тестов состоит из 3 этапов:

1. Настройка тестовых данных.
2. Вызов тестируемого кода.
3. Проверка возвращаемых результатов.

Например у нас есть функция для вывода максимально числа из массива:

```go
func Max(numbers []int) int {
    var max int

    for _, number := range numbers {
        if number > max {
            max = number
        }
    }

    return max
}
```

И нам нужно написать для неё тесты, и для начала нужно придумать тестовые данные, которая она примет, т.к. на вход она принимает массив чисел, его мы и передадим `{1, 2, 5, 7, -2, 15, 14, -15}`, также нужна проверка финального резултата, который мы ожидаем от выполнения этой функции, из данного массива видно, что это число 15.

Пример тестирования функции `Max()`

```go
func TestMax(t *testing.T) {
    // Настройка тестовых данных.
    numbers := []int{1, 2, 5, 7, -2, 15, 14, -15}
    expected := 15

    // Вызов тестируемой функции(кода)
    result := Max(numbers)

    // Проверка возвращаемых резултатов
    if result != expected {
        t.Errorf("Incorrect result. Expect %d, got %d", expected, result)
    }
} 
```

Чтобы выполнинть тестирование нужно в консоль написать команду `go test`, а чтобы выводить полную информацию тогда просто добавляем флак `go test -v`.

Но лучшей практикой в тестированиие считается, когда мы настраиваем большее количество тестовых данных для большего покрытия, чтобы учесть все варианты, поэтому лучше передовать тестовые данных через массивы струтуры:

```go
testTable := []struct {
    numbers []int
    expected int
}{
    {
        numbers: // some array
        expected: some int
    }, 
    {
        numbers: // some array
        expected: some int
    }
}
```

А проверку совершать с помощьью цикла проходя по всему массиву:

```go
for _, testCase := range testTable {
    result := Max(numbers)

    if result != expected {
        t.Errorf("Incorrect result. Expect %d, got %d", expected, result)
    }
}
```